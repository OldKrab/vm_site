= Маленькие механизмы отведения объектов в куче 

== Индексированный поиск свободных блоков

● Возьмем механизм последовательного поиска
● Главный его недостаток - линейная
алгоритмическая сложность по размеру кучи
● Дополним его структурой для эффективного
поиска по свободного блока по размеру 
● Поиск блока по точному совпадению размера
● При неудаче, поиск свободных блоков большего
размера
● Вставка и удаление блоков
● Например, построим префиксное дерево (trie, бор)
с размером блока в качестве ключа
● Будем хранить узлы этой структуры в самих
свободных блоках
● Сравнительно высокий минимальный размер блока

== Поиск свободного блока в битовом
массиве
● В качестве основы возьмём два пула
последовательного отведения
● В одном храним отводимые блоки
● В другом - битовые признаки их занятости
● Один бит на фиксированную единицу отведения
● При освобождении блока сбросим все его биты
занятости
● Слияние с соседними свободными блоками
произойдет автоматически
● Последний отведённый пулом блок вернем пулу
● При отведении блока сначала попробуем
найти свободный блок подходящего размера
● Последовательность нулей в битовом массиве
● Для этого у современных процессоров есть
специальные инструкции, поэтому реальная скорость алгоритма может быть очень хорошей. Ососбенно, если таблица оказывается в кеше