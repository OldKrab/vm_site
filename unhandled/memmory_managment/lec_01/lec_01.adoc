= Управление памятью

== Критерии сравнения систем управления памятью
=== 1. Замедление выполнения приложения
(execution time overhead)
● Иногда доля времени, проводимая приложением
в коде системы управления памятью (mark/cons
ratio)

Не вполне корректная мера — часть работы
управления памятью может быть перенесена в
код приложения и наоборот

Например, система управления паматью  может
повышать локальность, уменьшая частоту
кэш-промахов приложения

=== 2. Затраты памяти (space overhead)
● Доля памяти, недоступной приложению, во всей
отведенной для него ОС памяти
● Иногда коэффициент фрагментации -
отношение объемов недоступной и доступной
приложению памяти

=== 3. Распределение длительности пауз
● В идеале каждый вызов системы управления
памятью должен обрабатываться за фиксированное
и притом малое время
● Чуть хуже, если время обработки запроса
пропорционально размеру объекта
● Все равно все поля объекта нужно
инициализировать, поэтому время все равно потратится. Исключение -- когда отводим стек, то выделяем только указатель. 
● Контрпример - отведение стека в виде массива не
требует инициализации его тела
● Недостаточно ограничить длительность каждого
вызова системы управления памятью
● Нужно, чтобы приложение успело выполнить
достаточно работы в промежутках
● Minimal Mutator Utilization (MMU) — минимальная
доля времени, проведенная в коде приложения, в
интервалах заданной длительности
● Bounded Mutator Utilization (BMU) — минимальная
доля времени, проведенного в коде приложения, в
интервалах большей или заданной длительности

Следующие критерии качетсвенные, их тяжело  измерить

=== 4. Простота использования
● Чем проще код приложения, тем лучше
=== 5. Простота настройки (эргономичность)
● В идеале система не должна требовать настройки, передавать ключи и т.д. В Java не все идеально: много сборщиков мусора и  ключей для их настройки.

== Управление памятью
● Статическое
● Смещение присваивается в процессе
компиляции или линковки
● Адрес присваивается не позднее, чем в момент
загрузки
● Динамическое
● Отведение и освобождение во время
выполнения программы

== Статическое управление памятью
Этапы подготовки программы к запуску
● Трансляция программы с ЯВУ на язык
ассемблера целевой машины
● Ассемблирование с получением объектного
модуля стандартного формата
● Линковка/компоновка/редактирование связей.
Один или несколько объектных модулей,
возможно, хранящихся в библиотеках,
превращаются в загрузочный/исполняемый
модуль
● Загрузка модуля в память операционной
системой и запуск процесса
● Инициализация среды выполнения (runtime)
программы. При этом выполняются
специфические для данного ЯВУ действия,
которые должны предшествовать выполнению
программы, но не могут быть поручены
стандартному загрузчику (который специфичен для ОС и хорошо отлажен для нее)

Что мы видем в ассемблерной программе? 

=== Сегменты (секции) и метки
● В ассемблерной программе статически
распределяемая память представлена
набором именованных сегментов (В GNU сегменты называются секциями)

Атрибуты сегмента

* Имя
* Группа (для объединения в процессе линковки)
* Класс (код, данные, константные данные,
неинициализированные данные, стек)
* Выравнивание начального адреса
* Переместимость (является позиционно-независимым, или должен быть изменен при перемещении. во втором случае есть доп мекция, где написано как и что менять)
* Текущая позиция в сегменте (в асм)
* Текущий размер (не меньше текущей позиции)
* ...

=== Метка — символическое имя, связанное со смещением в сегменте
=== Линковка
1. Объединение данных одного сегмента из
разных объектных модулей. В произвольном порядке или порядке
перечисления модулей в командной строке
2. Объединение сегментов в группы

* Порядок указан явно или согласно
лексикографическому порядку имен сегментов
* В GNU нет явных групп сегментов, но имя
секции может заканчиваться индексом, все секции с одним индексом будут объединены(по порядку его возрастания)
* Секции с одним именем сортируются и
объединяются в порядке возрастания индекса
 Затем происходит объединение в
лексикографическом порядке имен секций

3. Назначение началам сегментов логических
или абсолютных адресов
4. Назначение адресов меткам и разрешение
ссылок на них

=== Преимущества 

* Нулевые расходы на управление памятью во
время исполнения
* Отсутствуют целые классы сложных ошибок, невозможны
** Исчерпание памяти
** Висящие ссылки (на уже освобождённую память)
** Утечка памяти
**  Переполнение стека вызовов
* Не требуется аппаратной поддержки
** Стека вызовов
** Сложных режимов адресации
* Сравнительно легко поддается статическому
анализу (для доказательств свойств программы)

какие свойства можно доказывать? может ли алиас ссылаться на два объекта? в фортране нет, поэтому там легко все переставлять и это значительно ускоряет параллелизацию.

=== Ограничения и недостатки

● Невозможно отведение структур данных во
время исполнения программы
● Размеры всех структур данных должны быть
определены статически. Необходимо оценить и заранее отвести
максимальный возможный размер
● Затруднено применение рекурсивных
процедур. Локальные переменные и адрес возврата
отведены статически, два раза войти в одну функцию невозможно. Стека вызовов нет, информация о входе в функцию записывается в заголовке функции.
● Неэффективное использование памяти
● Резервирование структур данных по максимуму
размера
● Отведение всех секций активации