= Многопоточность 2 

== Синхронизация
Синхронизация в языке Java
● Низкоуровневая, трудна в использовании
● Синхронизированными могут быть методы и
блоки
● synchronized public void myMethod() {…}
● synchronized(obj) { … }
● Методы синхронизированы на объекте-
получателе (this)
● Статические методы синхронизированы на
статике определяющего их класса
● В каждый момент внутри синхронизированного
на одном объекте метода или блока может
находиться не более одного потока
● Другие потоки при попытке входа будут
заблокированы и поставлены в очередь ожидания

Реализация синхронизации (1)
● Виртуальная машина ассоциирует объект с
монитором и очередью ожидания
● При входе в синхронизированный метод или
блок (байткод monitorenter) пытаемся
захватить монитор объекта синхронизации
● Если монитор был свободен, продолжаем
исполнение
● Если нет, становимся в очередь, отдаем
управление планировщику
● При выходе из синхронизированного метода
или блока (байткод monitorexit) пытаемся
освободить поток из очереди ожидания
объекта синхронизации
● Мониторы — короткоживущие объекты
● Мониторы широко используются в библиотеках
● Эффективность реализации мониторов
критична для производительности VM

* Наблюдение 1: синхронизация происходит на
очень небольшом числе объектов
** Это свойство устойчивое — если однажды объект
использовался для синхронизации, вероятно, что
он будет для этого использоваться вновь
** Следствие: не надо раньше времени ассоциировать объект с
монитором и разрушать эту ассоциацию
* Наблюдение 2: чаще всего при входе в
синхронизированный блок монитор свободен. 
** Uncontended — имеется только один желающий
его захватить поток

=== Пример реализации

* У объекта в заголовке имеется указатель
monitorOrHashCode
* Вследствие выравнивания два младших бита
его свободны, это используют как флаг состояния потока.
** 00 — старшие 30 битов содержат хэш-код
** 01 — uncontended monitor, в старших битах адрес
захватившего монитор потока
** 10 — extended uncontended monitor — кратное
вхождение потока в один и тот же монитор, в
старших битах адрес потока
** 11 — contended locking. В очереди ожидания
имеются другие потоки. Старшие биты содержат
адрес монитора. Сам монитор отведен на стеке
захватившего его потока

Зачем разделять 01 и 10? Чтобы разделять когда мы выходим из рекурсивного и все еще захватываем ресурс или выходим и освобождаем. Дополнительно где-то еще хранится счетчик.

== Модель памяти

Современные ЭВМ не являются строго
последовательными
* Несколько процессоров
* Несколько потоков выполнения в каждом
* Потоки могут переупорядочивать инструкции
*  Обращения к памяти буферизуются и кэшируются

Модель памяти определяет правила, которым
должны следовать многопоточные
программы для получения
детерминированных результатов. Чтобы ее реализовать вводятся специальные инструкции

* Атомарные
* CAS
* Обеспечение когерентности кэшей
* Барьеры обращения к памяти (fences)

 Для платформенной независимости VM
должна определять свою модель памяти

=== Пример: Java Memory Model
Определяет *наблюдаемый частичный порядок* над
действиями. В частности, порядок транзитивен. Частичный -- значит, что  сущетсвует только над подмнрожеством действий 

* В пределах одного потока порядок выполнения
инструкций определяется их последовательностью
* Для каждого монитора операция unlock происходит
перед каждой последующей операцией lock
* Для каждого волатильного поля запись происходит перед каждым последующим чтением
* Выполняемые потоком действия начинаются после
его старта и заканчиваются до того, как любой
другой поток увидит его (потока) завершение 
* Прерывание одного потока другим происходит до
того, как первый обнаружит это прерывание
* Финализатор объекта выполняется после
завершения его конструктора

● У этих правил сложные последствия
● Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Boebeer,
David Holmes, Doug Lea. Java Concurrency in Practice.
Eddison-Wesley, 2006
● В этой книге около 500 стр.
● Семантика нарушающей правила программы не
определена
● Правила ограничивают компиляторные
оптимизации
● Например, волатильные поля нельзя кэшировать в
локалах


Для удобства применения правил вводятся специальные языковые конструкции, разрабатываются специальные библиотеки

* Синхронизированные коллекции
* Конкурентные коллекции
* Блокирующие очереди
* Синхронизаторы
* ...