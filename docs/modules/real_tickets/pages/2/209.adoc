= 2.9. Защищенные и незащищенные спекулятивные преобразования

*Спекулятивное* преобразование -- если хотя бы частично основано на не доказанных компилятором предположениях.

*Защищенное* спекулятивное преобразование -- выполнению преобразованного кода предшествует проверка предположений с деоптимизацией - страж (guard). Деоптимизация -- переход в версию кода без предположения. Деоптимизация происходит лениво, только когда будет проверятся проверка при исполнении этого кода.

*Незащищенное* спекулятивное преобразование -- Выполнение преобразованного кода без проверки. Предположения проверяет внешний агент. Как только проверки не выполняются, то агент что-то делает с кодом.

== Защищенные спекулятивные преобразования

Такой код с проверкой всегда корректен, но не оптимален. Стражи занимают место в коде, а выполнение проверок занимает время.

Чтобы улучшить ситуацию, компилятор должен оптимизировать стражей:

* Вытаскивать проверки из циклов
* Изводить общие подвыражения проверок
* Сохранять результаты проверок как биты в маске, и проверять комбинацию этих условий через битовые операции.

== Незащищенные спекулятивные преобразования

Скомпилированный код регистрируется в VM. Этот код должен содержать таблицу предположений. Для каждого предположения есть точки проверок и деоптимизаторы этих точек.

Проверки могут быть только те, которые понятны VM, в отличии от защищенных преобразований, где эти проверки могли быть произвольными.

VM гарантирует, что не начнет исполнять преобразованный код, если все его предположения не верны.

Компилятор гарантирует, что предположения были верны во время компиляции.

Преимущества в том, что не нужно порождать стражей и заниматься их оптимизацией.

При инсталляции преобразованного кода VM проверяет, что предположения все еще корректны.

VM устанавливает обработчики событий для обнаружения будущих изменений (нарушений) в предположениях.

VM способна замечать следующие изменения:
* Инициализация подкласса указанного класса
* Перекрытие указанного метода
* Изменение глобальной переменной

При срабатывании обработчика событий VM:

. Проходит по всех зависящим от него скомпилированным методам, хорошо, что они зарегистрированы
. Переписывает заголовок метода так, чтобы вызовы происходили в интерпретаторе
. Переходим по таблице и находим все точки деоптимизации метода
. Переписываем код точек деоптимизации, активизируя ее обработчик

Деоптимизация не будет произведена, пока выполнение кода само не дойдет до точек деоптимизации. Этого можно ждать долго, если секция глубоко в стеке или выполняется долгий цикл. Зато такая ленивая деоптимизация -- это хороший способ для медленного компилятора. 

В однопоточной VM, в момент срабатывания обработчика события, все секции стека, включая верхнюю, находятся в каких-то точках деоптимизации. Обработчик события не откладывает деоптимизацию, а сразу выполняет ее. Из-за чего от скомпилированного кода можно сразу избавиться, что хорошо для быстрого компилятора.

== Примеры спекулятивных преобразований

* Частичная компиляция (исключаем холодный код)
* Девиртуализация вызовов
* Изведение проверок предположительно ложных условий (напр., instanceof)
* Предположения о неизменности глобальных переменных
* Макроподстановка и декомпозиция объектов (можем разложить объект на локальные переменные, если передача ссылки на объект не выполняется)
* Специализация полиморфного кода по популярным типам аргументов
* Специализация векторных операций по типу и размерности операндов



