= 2.1. Компиляция статическая, динамическая и комбинированная

Когда мы можем компилировать?

* До выполнения (статическая компиляция)
* Во время выполнения (динамическая компиляция)
** При старте приложения
** Лениво при первом выполнении программной единицы
** Адаптивно под управлением профилятора
* Комбинированный вариант

== Статическая компиляция

Классическая компиляция, которая выполняется конвертором. Во время нее используются хорошо известные алгоритмы.

Чтобы исполнять готовую программу, нам не нужен интерпретатор.

Во время статической компиляции можно использовать глубокий анализ кода, что требует много памяти и времени.

Глубокий анализ кода слабо применим к динамическим языкам.
====
В Java есть виртуальные и динамические вызовы, а также динамическая загрузка классов и рефлексия, что тяжело анализировать статически.
====

Глубокий анализ кода слабо применим к большим библиотекам, т.к. использование динамики в отдельных компонентах библиотеки приводит к фатальному падению анализа всего кода.

#TODO: рассказать про разные виды линковки при статической компиляции#

== Динамическая компиляция

=== При первом старте 
Можем отложить классическую компиляцию до старта приложения. Тогда нам уже будут известны все параметры запуска (например, отладка). 

Но целевое устройство, на котором происходит компиляция, ограничен в ресурсах, от чего первый запуск может быть долгим. 

От анализа кода приходится отказываться.

=== Откладывание компиляции программной единицы до первого выполнения
Также называется *Just In Time* компиляция. 

Компиляция всего приложения распределяется во времени, но неравномерно и неконтролируемо.

Зато мы исключаем компиляцию недостижимых программных единиц.

Можно производить оптимизации на основе динамического состояния.

Минусы: будет скомпилирована любая исполняемая единица, даже если она исполняется единожды (например, инициализация класса).

== Комбинированный вариант 

Конвертируем программу в специфичный для VM машинно-независимый LIR, производя анализ и машинно-независимые оптимизации.

Во время выполнения по нему и результатам анализа быстро порождаем машинный код.