:lang: ru-RU
:source-highlighter: rouge

= 1.3 Виды линейных кодов.


== Байтовый код
Код представляется токенами размера 1 байт (??)

*Пример байтового кода*
 
image::103/bytecode.png[]

 0 - адрес переменной а, 1 - b 

Ниже его интерпретатор на С. В цикле считаем следующий байт, в зависимости от его значения -- выбираем номер следующей инструкции. Логика функции в теле case.

*Интерпретатор байтового кода на С*

```C 
void Interpreter (void) {
    const byte* ip;
    ...
    for (;;) {
        switch (*ip++) {
        ...
        case iadd: {
            const int a = pop();
            const int b = pop();
            push(a+b);
            break;
        }
    ...
        }
    }
}
```
*Интерпретатор байтового кода на assembler*

На asm можно явно выразить некоторые вещи. Например, задать #явный# или #неявный# цикл

*Интерпретатор байтового кода с #явным# циклом*

```asm
InterpreterLoop:
    ; мб 1 инструкция
    tmp = *ip++;
    jmp BytecodeTable[BytesInWord * tmp];
    ...
L_iadd:
    pop tmp1;
    pop tmp2;
    tmp1 += tmp2;
    push tmp1;
    ; ЯВНО переходим на начало цикла
    ; как и все другие инстуркции
    jmp InterpreterLoop;
    ...
BytecodeTable: .word ..., L_iadd, ...
```

====
Здесь `ip`, `tmp`, `tmp1`, `tmp2` — машинные регистры,
причем tmp может совпадать с `tmp1` или `tmp2`.

`BytecodeTable` -- это массив адресов обработчиков каждой инструкции. Индексируется токеном инструкции.

`BytesInWord * tmp` -- в примере tmp - сам токен, а BytesInWord - размер указателя, поэтому такая операция дает нам адрем обработчика токена.
====
Явный цикл заключается в том, что в конце каждого обработчика мы совершаем безусловный переход в InterpreterLoop, где читаем адрес следующей инструкции и совершаем второй переход. Два перехода - лишняя косвенность.



*Интерпретатор байтового кода с неявным циклом*



```asm
next:   macro()
        tmp = *ip++;
        jmp BytecodeTable[BytesInWord * tmp];
        endm

Interpreter:
        next();
...
L_iadd:
        pop tmp1;
        pop tmp2;
        tmp1 += tmp2;
        push tmp1;
        ; здесь подставится код макроса!!!
        next();
...
BytecodeTable: .word ..., L_iadd, ...
```

====
Макрос next выполняет роль начала InterpreterLoop из интерпретатора с явным циклом - читает следующий токен и отдает управление на таблицу интерпретатора.
====

В случае неявного цикла, мы в конце каждой инструкции совершаем один безусловный переход сразу на обработчик следующей инструкции.

А также мы облегчаем работу предсказателю переходов: обычно после одной инструкции чаще идут определенные инструкции (например, в lama, после call мы обычно выполняем begin), что поможет предсказателю переходов ускорить выполнение, запоминая такие связи. 

Но, с другой стороны, если количество инструкций большое, то память предсказателя переходов переполнится, и предсказания станут хуже.

== Шитый код
Код -- последовательность адресов подпрограмм.

Подпрограмма может быть написана как на промежуточном языке, так и на машинном языке. 

Подпрограмма на промежуточном языке полностью состоит из адресов других подпрограмм, которые нужно вызвать. Например, это может быть функция исходного интерпретируемого языка.

Подпрограмма на машинном языке реализует I/O или какую то базовую арифметическую операцию.

Происходит постоянный переход от одной подпрограммы к реализации другой. Если представить это линией, то они словно сшиты. Поэтому код #шитый#.

Выделяют три вида шитого кода 

* Подпрограммный
* Прямой
* Косвенный

Может быть несколько реализаций интерпретатора,главное чтобы каждому enter соответствовал exit того же интерпретатора (как ПСП).

=== #Подпрограммный# шитый код
image::103/threaded_code.png[]

`jsr` — машинная инструкция вызова подпрограммы (от процессора `pdp`, у `intel` -- `call`). Кладет адрес следующей инструкции на стек (адрес возврата) и изменяет `ip` на адрес подпрограммы.

`ret` — машинная инструкция возврата из подпрограммы. Снимает со стека адрес возврата и меняет `ip` на него.

`iload`, `iret` -- метки реализаций подпрограмм  


Цикл интерпретатора отсутствует:

```asm
.code
...
iadd:   pop(tmp1);
        pop(tmp2);
        tmp1 += tmp2;
        push(tmp1);
        ;вернуться в исполнение кода 
        ; на следующий jsr 
        ret
```
====
`iadd` — метка в коде

`tmp1`, `tmp2` — регистры процессора

`pop`, `push` — макросы операций со стеком операндов. Одноименные инструкции использовать нельзя, так как аппаратный стек работает с адресами возвратов, а `pop`, `push` с передачей операндов. Поэтому реализуем макросы!
====

Скорость: не так медленно, так как процессор умеет предсказывать `ret`. И это в любом случае быстрее, чем в ручную искать адрес следующей операции через табличку. 

* Быстрее байтового 
* Количество инструкций не ограничено (в отличии от байтового)
* эффективен, когда адрес подпрограммы не очень длинный (иначе дорого хранить) и абсолютный (иначе приходится выполнять арифметические операции)

Где используется: postscript (pdf), forth

=== #Прямой# шитый код 
В подпрограммном коде каждую инструкцию мы выполняли как подпрограмму, из-за чего у нас на каждую инструкцию в байткоде был op-код `jsr`.

Хочется убрать этот op-код из байткода, оставив только адреса обработчиков инструкций, чтобы уменьшить размер байткода примерно на 1/3. Но если мы уберем `jsr`, мы не сможем больше исполнять байткод напрямую процессором, т.к. в нем остались только адреса.

image::103/right_thread.png[]

Мы теперь не будем пользоваться аппаратным регистром для текущей инструкции (PC or IP), а заведем свой программный регистр `ip`, который перемещается по адресам в байткоде.

Также вводятся три макроса: `next`, `enter` и `exit`.

`next` -- прочитать текущий адрес из ip, сдвинуть ip, и перейти по прочитанному адресу.

`enter` -- сохранить текущий ip в стек возврата, записать в ip адрес следующей инструкции, и вызвать `next`.

`exit` -- восстановить ip из стека возврата и вызвать `next`.

Когда мы входим в подпрограмму, мы начинаем исполнять его процессором как обычный код. Поэтому первая инструкция содержит `jsr` с меткой `enter`.

Но в отличии от подпрограммного шитого кода, процессор не вернется в этот код на следующую инструкцию. Вместо этого в `enter` мы вызовем макрос `next`, который прочитает адрес следующей подпрограммы, и сделает `jmp` в нее.

*Интерпретатор #прямого# шитого кода*

```asm
next:   macro()
        ; чтение слова -- адреса инструкции
        tmp = *ip++;
        jmp tmp;
        endm
        
enter:  rpush(ip);
        pop ip;
        next();

        ;cнимаем старый адрес интерпретации
exit:   rpop(ip);
        next();

iadd:   pop tmp1;
        pop tmp2;
        tmp1 += tmp2;
        push tmp1;
        next();
```
====
pop, push — машинные инструкции

rpop, rpush — макросы операций со стеком возвратов
====



=== #Косвенный# шитый код 
Это вид шитого кода, который не содержит машинных инструкций, а содержит только адреса подпрограмм.

image::103/indirect_threaded_code.png[]

****
Dewar, R.B.K., Indirect threaded code.
Communications of the ACM, June 1975, pp.330-331
****


*Интерпретатор косвенного шитого кода*

```asm
next:   macro()
        tmp = [ip++];
        jmp [tmp];
        endm

enter:  rpush(ip);
        ; в tmp храним адрес текущего enter из кода
        ; двигаем его на машинное слово и получаем адрес 
        ; следующей инструкции (iload)
        ip = ++tmp;
        next();

exit:   rpop(ip);
        next();

iadd:   .word @iadd
; фиктивная метка реализации
@iadd:  pop tmp1;
        pop tmp2;
        tmp1 += tmp2;
        push tmp1;
        next();
```

В прямом шитом коде мы начинали выполнять первую инструкцию в подпрограмме. В косвенном шитом коде мы убрали `jsr` из кода, поэтому в начале подпрограммы остался адрес другой подпрограммы (в примере это `enter`). 

Поэтому, чтобы выполнить некоторую подпрограмму, мы должны сначала прочитать адрес этой подпрограммы (как в прямом шитом коде), а затем прочитать в ней адрес первой подпрограммы, которую уже можно исполнять (для подпрограмм на промежуточном коде - это `enter`, для подпрограмм на машинном коде - это адрес машинного кода инструкции).

Также используется дополнительный регистр tmp, который хранит адрес текущей подпрограммы (в прямом шитом коде он клался на программный стек комадной `jsr`).

В начале каждой инструкции должен лежать адрес следующей за ней реализации инструкции

`-` интерпретатор сложнее -- дополнительная косвенность, загружаем адрес из памяти, вводим фиктивные метки -- работает медленнее прямого кода
  
`+` нет никаких машинных инструкций, абсолютно независимый от платформы. Можно делать фиксы чтобы поправить адреса

****
Очень хорошо рассказано про шитый код здесь: https://muforth.dev/threaded-code/
****

== Токен-шитый код
Гибрид байтового и шитого кода

Полезен, когда нужно выполнить переход между скомпилированным и интерпретируемым кодом.

===  #Прямой# токен-шитый код
Байтовый код встроен в прямой шитый как вариант интерпретации. Инструкция вызова передает управление на
начало кода вызываемой функции.

Нормальный байтовый код, перед которым написан jsr на интерпретатор 

Байтовый код остается таким же медленным, но можно сочетать разные интерпретаторы в рамках одной программы

image::103/direct_ttc.png[]

```asm 
Interpreter:
        ; сохраняет адрес возврата
        rpush(ip);
        ; снимает с аппаратного стека адрес 
        ; первой инструкции (iload 0)
        pop ip;
        next();
L_iadd:
        pop tmp1;
        pop tmp2;
        tmp1 += tmp2;
        push tmp1;
        next();

next:   macro()
        tmp = *ip++;
        jmp BytecodeTable[BytesInWord*tmp]
        endm
```

 ?? когда будет происходить rpop

=== #Косвенный# токен-шитый код
Инструкция вызова загружает адрес начала кода вызываемой
функции в регистр tmp и передает управление по хранящемуся
там адресу интерпретатора

```asm
Interpreter:
rpush(ip);
ip = tmp + BytesInWord;
next();
L_iadd:
pop tmp1;
pop tmp2;
tmp1 += tmp2;
push tmp1;
next();
next: macro()
tmp = *ip++;
jmp BytecodeTable[BytesInWord*tmp]
endm
```

image::103/indirect_ttc.png[]