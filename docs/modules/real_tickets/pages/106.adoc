:lang: ru-RU
:source-highlighter: rouge
= 1.6 Организация стека вызовов


Реализация ВМ ограничивает максимальные *глубину стека вызовов* (сложно посчитать статически) и *размер записи активации* (проверяется верификатором).

Способы реализации стека:

* максимальное резервирование памяти (фактически она гораздо меньше, много памяти пропадает зря. неразумный!!)
* максимальное резервирование адресного пространства 
* непрерывный перемещаемый эластичный стек 
* кусочный неподвижный стек переменной длинны

== Максимальное адресного пространство
При страничной адресации зарезервируем страницы с запасом на одну максимальную секцию. Заполняем по мере необходимости.

Зеленое -- отображенные страницы, красные -- еще нет.

image::106/call_stack_max_address.png[]

У некоторых ОС есть функции отображения растущих вниз адресов (нужно указать, что это стек). Можно и сокращать стек (вручную).

`-` адресное пространство не бесконечно (ограничено процессором, чипсетом, ОС)

`-` в некоторых языках (функциональных и т.д.) может быть много стеков. Если под каждое будем резервировать -- память быстро кончится.

`-` резервирование памяти -- медленная функция ОС. Можно соптимизировать, завести пул стеков популярного размера.

`-` когда активно резервируем -- увеличиваем таблицу страниц и память работает медленнее.

== Кусочный неподвижный стек 
Делим стек на фрагменты одинакового размера (не меньше максимального размера секции активации)

Проверка переполнения обычно аппаратная (перограммная тратит много ресурсов??). При переполнении отводим новый фрагмент. Для ускорения заводим пул обектов. 

При выходе из верхней секции фрагмента -- возвращаем фрагмент в пул. Чтобы каждый раз не проверять, не последняя ли это секция -- в начале фрагмента храним фиктивную секцию активации, которая сбрасывает текущий фрагмент и переключается на предыдущий. 

*Пример*

image::106/сhunky_fixed_stack.png[]

Начинаем с фрагмента 0. Его специальная секция (на картинке справа) обрабатывает выход из языкового объекта совсем (из потока или подпрограммы).

Вызываем какие-то функции, получая динамическую цепочку из их секций активации. Как только вызываем функцию, аппетит которой превышает свободное место -- заводим новый фрагмент из пула. 

Если ВМ многопоточная -- можно для каждого потока заводить свой пул.

== Непрерывный перемещаемый эластичный стек

Проверка переполнения -- программа или с защитой страниц. 

При переполнении пытаемся дорастить его, если есть непрерывно прилегающая свободная память. Если его нет -- копируем весь стек в новое место. 

Для этого нужно *#релоцировать#* адреса в стеке -- пройти по динамической цепочке вверх и перенастроить ее локальные адреса, т.е. мы должны знать форматы *каждой* секции!! Нельзя вызывать код с неизвестным форматом или с нативным кодом.

`+` можем не знать максимальный размер секции активации

`-` может закончиться память в куче, это более общее исключение 
