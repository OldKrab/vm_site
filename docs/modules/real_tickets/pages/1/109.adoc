= 1.9. Оптимизации при преобразовании распространяемого кода в исполняемый. Специализация инструкций по непосредственным операндам. Замена идиом на супер-инструкции

== Оптимизации в конверторе распространяемого кода в исполняемый

.Особенности конвертора
* Конвертор может не обладать значительными вычислительными ресурсами 
** Например, в небольшом устройстве
* Знает VM и устройство, на которых будет выполняться код 
** в том числе все библиотеки на устройстве
* Менее ограничен раздельной компиляцией
** Локально храним зависимости
** При обновлении распространяемого кода переконвертируем его и все зависимые модули
* Больше полезных оптимизаций и возможностей их применения, чем у компилятора исходного кода
** Можем оптимизировать приложение целиком (все модули с зависимостями)
** Но для этого нужно иметь высокоуровневое представление программы, которое почти ничего не теряет от исходной программы
*** Обычный байткод слишком низкоуровневый для оптимизаций

.Полезные оптимизации в конверторе
* Языко-зависимые оптимизации
** Например, в Java конвертор может выборочно статически инициализировать классы, чтобы не делать этого при выполнении 
* Конвертор может выполнять оптимизации интерпретатора
** Например, конвертор инициализировал класс и поэтому знает, что он останется инициализированным
* Альтернативные версии сконвертированного кода
** Например, отладочная версия без оптимизаций

И другие более интересные оптимизации далее.

== Специализация инструкций по набору непосредственных параметров

Малые константы и малые смещения локальные переменных встречаются гораздо чаще.

Заведем для них специализированные инструкции:

* `<type>const_<value>`
* `<type>load_<offset>`

Код становится короче и быстрее, т.к. числовой параметр зашит в инструкцию, его не нужно дополнительно вычитывать из кода.

Но свободный инструкций не так много (если это не шитый код).
[NOTE]
====
Можно первый байт считать признаком расширения кода, а второй - сама инструкция, но это декодируется в два раза медленнее.
====


== Замена идиом

*Идиома* — часто встречающаяся последовательность виртуальных инструкций.

====
Например, прочитать поле this: +
```
aload_0
<t>getfield <index>
```
====

Мы знаем, что нет переходов внутрь этой последовательности.

Также известно, что текущий объект не `null`.

====
В примере с `this` интерпретатор не смог бы вызвать метод с `this = null`

Но в байткоде можно присвоить `this = null` через `astore 0`, поэтому конвертор должен это проверять
====

Для такой идиомы заведем _супер-инструкцию_, которая реализует эту идиому.

====
Например, `aload_0_<t>get_field_<offset>`

Но мы можем выполнить замену, только если знаем `<t>` и `<offset>` поля, иначе мы не можем сделать такую замену.

Тогда мы можем заменить в коде `aload_0` на `quick_aload_0`, чтобы подсказать интерпретатору сделать эту замену при выполнении этой инструкции.
====

Супер-инструкции можно использовать для сжатия кода. Для этого напишем анализатор кода, который найдет в коде приложения и библиотек заданное количество идиом заданной длины, и породит оптимизированный код для реализации этих супер-инструкций. Удобнее применять с шитым кодом, т.к. он имеет неограниченное количество инструкций. Такой сжатый код не нужно распаковывать для выполнения.

Супер-инструкции тяжело отлаживать, нельзя остановиться внутри идиомы. 






