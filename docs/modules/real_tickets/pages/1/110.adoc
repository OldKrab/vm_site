= 1.10. Оптимизации при преобразовании распространяемого кода в исполняемый. Макроподстановка вызовов простых функций

Многие функции простые и короткие:

* Их код позиционно-независим (можно перемещать в памяти)
* Не содержит сложных инструкций
** Ссылки на пул констант в одном классе потребуют копирования пула в другой класс при макроподстановке
** Try-catch в java сложный и используем различные талицы для обозначения блока
* Его можно просто скопировать в другой метод
** Если отсутствуют локальные переменные
** Параметры этой функции передаются через стек операндов

====
Например, аксессоры полей.
====

Ограничения выше решаемы и не запрещают макроподстановку, а лишь усложняют ее.

*Решение*: подставим тело такой функции вместо ее прямого вызова:

* Может сократить код, если вызов этой функции занимал больше места
* Если все вызовы функции подставлены, определение функции можно удалить (но мешает рефлекция)
* Ускоряется выполнение кода
** Могут появиться новые идиомы 

Макроподстановка может быть заметна при:

* Бросании исключений из подставленного кода, т.к. в трасе отсутствует секция подставленного метода
** Можно в таблицах соответствия инструкций байткода исходному коду хранить весь стек подставленных методов, а не только позицию исходного кода
* Исчерпании стека 
+
====
Например, подставляемая функция имела локальные переменные, но в вызываемой функции выполнялась при редко вычислимом условии. При подстановке количество локальных переменных у вызывающей функции увеличивается, и это может привести к переполнению стека, что без макроподстановки не случалось.
====
* Профилировании, отладке и инструментировании кода