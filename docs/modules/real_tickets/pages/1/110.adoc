= 1.10. Оптимизации при преобразовании распространяемого кода в исполняемый. Макроподстановка вызовов простых функций

== Ограничения на функции

Многие функции простые и короткие. Длина функции важна только если ресурсы конвертера ограничены.

Код должен быть *позиционно-независим*, можно перемещать в памяти. У них либо нет переходов, либо переходы закодированы относительно индекса инструкции перехода. 


Код не должен содержать *сложных для подстановки инструкций*:

* Ссылки на чужой пул констант. Например, из одного класса в другой. Это потребуют копирования пула при макроподстановке
* Try-catch в java сложный и используем различные талицы для определения обработчиков исключений. При подстановке нужно будет сливать таблицы.
* Бросание исключений (если в языке это сложная инструкция). Трасса стека будет не точной. В Java по спецификации так нельзя! 

Копирование усложняют:

* Локальные переменные (их нужно сливать, менять индекс, менять рамку стека)
* Передача параметров НЕ через стек операндов. Если параметры передаются через стек -- то ссылок на локальные переменные нет (??). Нужно отличать локальные переменные подставляемой функции и внешней.

====
Например, аксессоры полей.
====

Ограничения выше решаемы и не запрещают макроподстановку, а лишь усложняют ее.

== Реализация 

Подставим *тело* такой функции вместо ее прямого *вызова*:

== Преимущества

* Может сократить код, если вызов этой функции занимал больше места

* Если все вызовы функции подставлены, определение функции можно удалить. Конвертор анализирует код целиком и может заметить, что других вызовов нет

 Удаляем тело, уменьшаем таблицы, выигрываем пространство. Но мешает рефлексия - метод могут искать по имени. Рефлексия делает вещи, неизвестные конвертору. Это совсем плохо, если по имени к этой функции обращались из нативного кода. 

* Ускоряется выполнение кода за счет удаления вызова (это может быть много инструкций) и оптимизации появившихся идиом.

== Недостатки 

Макроподстановка может быть заметна при:

=== 1. Исключения из подставленного кода
Бросании исключений из подставленного кода, т.к. в трасе отсутствует секция подставленного метода.

Обычно в коде лежит таблица с соответствием между индексами (смещениями) виртуальных инструкций и позициями в исходном коде. 

Можно в таблицах соответствия инструкций байткода исходному коду хранить весь стек подставленных методов, а не только позицию исходного кода

=== 2. Исчерпание стека 
+
====
Например, подставляемая функция имела локальные переменные, но в вызываемой функции выполнялась при редко вычислимом условии. При подстановке количество локальных переменных у вызывающей функции увеличивается, и это может привести к переполнению стека, что без макроподстановки не случалось.
====

=== 3. Профилировании, отладке и инструментировании кода