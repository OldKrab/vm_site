:lang: ru-RU
:source-highlighter: rouge

= 1.7 Нативный интерфейс виртуальной машины. Доступ к данным


Раздел "Нативный интерфейс виртуальной машины" включает несколько разделов, но в билеты вошли только xref:1/107.adoc[доступ к данным]. Однако, остальные доступны по ссылкам ниже.

* xref:1/107_call_lib_funcs.adoc[Нативный интерфейс VM: Вызов библиотечных функций] 

  вызов нативного кода из интерпретируемого

* xref:1/107_callbacks.adoc[Нативный интерфейс VM: Callback-функции] 

 вызов интерпретируемого кода из нативного

== Доступ к данным из нативного кода
Хотим передавать данные и делать с ними что-то содержательные. Хотим получить доступ к данным виртуальной машины из нативного кода.

=== Динамическая нативная рефлексия
Получаем информацию об объектах через сервисные (??) функции

+ всегда работает 

- неэффективна 

- требует хранения служебных имен 

- затрудняет анализ ссылок из нативного кода (тяжело проверить, как функции/поля используются в коде)


То же самое, что #позднее связывание по имени# (строке или
символу)

#Символ (атом)# — зарегистрированная строка. При повторной регистрации выдается тот же адрес. Искать адреса быстрее, чем значения строк.

 Но нужно где-то запомнить символ

```java
ClassHandle klass = find_class(«MyClass»);
FieldHandle field = klass.find_field(«myField»);
//прочитать такое поле у объекта,
//который мы передаем параметром
int value = field.read_int(obj)
```

=== Статическая структурная рефлексия 
Генерируем заголовки для нативного кода, где объекты ВМ видны как объекты нативного кода 

* struct в C
* class с аксессорами полей в C++

  Аксессоры удобнее — в них можно завернуть семантики, навешанные на доступ к полям определенных типов. Например, сборщику мусора могут быть интересны изменения ссылочных полей, в аскессоре можно делать нотификацию для GC

```cpp
//Object -- стандартный класс ВМ с заголовком
class MyClass: Object { // Наследуем заголовок
        int _myField;
    public:
        int myField() const { return _myField; }
        int setMyField(int val) { _myField = val; }
};
```

 Зачем нужен заголовок? Хранить служебные поля, обрабатывать при сборке мусора (обрабатывать все ссылки).


+ эффективна (почти прямой доступ к объектам)

- применима только к замкнутой модели мира (можем пользоваться только этими заголовками, если подгрузим объект -- будет беда)

- не все структуры вм имеют аналог 

 например, когда заголовок объекта - в середине. Зачем они нужны? Например, для сборки мусора - справа будут ссылочные поля, слева - все остальные. Первые очень быстро проверить (появилось в Self)

=== Смешанная рефлексия 
Для известной части Вселенной -- статическая, для всего остального -- динамическая (динамически загружаемые классы, в т.ч. определенных пользователем)