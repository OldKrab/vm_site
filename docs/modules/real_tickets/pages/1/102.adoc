:lang: ru-RU
:source-highlighter: rouge

= 1.2 Представление виртуальных инструкций. Передача параметров инструкциям.

== Представление виртуальных инструкций. 
=== Токен 
** Целое число, однозначно идентифицирующее инструкцию и, возможно, все или некоторые из ее операндов
** Остальные операнды могут быть закодированы в потоке инструкций вслед за токеном
** Токены не зависимы от аппаратуры и размещения кода в памяти
** Пример: байтовые коды Smalltalk VM или JVM

=== Адрес подпрограммы
** Единственная инструкция — вызов подпрограммы, подразумеваемая по умолчанию
** Набор инструкций легко расширяется, добавляя адреса их реализаций
** Пример: шитый код Forth-машины

== Передача параметров инструкциям.

Какие параметры бывают?

* *Неявные* на вершине стека операндов 
+
====
Например, сложение. Ее параметры где-то на стеке, в самой инструкции не указаны
====

* В *виртуальных регистрах*
** явные (указываем виртуальный регистр явно)
** неявные (инструкция перехода модифицирует адрес следующий инструкции, мы не указываем какой именно регистр)

* *Непосредственные* операнды
** Значения разных типов, в т.ч. структурных
** Номера регистров (при явной передаче параметров в регистрах)
** Позиции меток в коде
** Ссылки на объекты и их элементы (например, класс или поле объекта)
** Внешние символические ссылки (когда вызываем функцию из стандартной библиотеки)


=== Явная передача в виртуальных регистрах

При компиляции для функции вычисляется количество нужных ей виртуальных регистров.

на картинке -- секции активации функции. Они могут быть типизированные или бестиповые:

image::102/virtual_reg.png[]

Сколько регистров нужно? Чтобы хватило для всех живых локальных переменных (в т.ч. временных).

Что делать, если регистров недостаточно? Номер регистра ограничен шириной отведенного для него битового поля инструкции. Возможные решения 

* запретить порождать такой код
* расширить поля номеров регистров 
* завести префикс ширины таких полей
* использовать кодировку переменной длины
* использовать деление по типам (регистры более экономично расходуются)


Регистры указываются в инструкции вызова.

Инициализация регистров:

1. Не инициализировано ничего, кроме параметров вызова
2. Инструкция вызова копирует заданные виртуальные регистры вызвавшей функции в регистры вызываемой
3. При возврате копируется результат в заданный регистр вызвавшей функции



==== Оптимизация: индексация параметров вызова

Подходит для бестиповых регистров, когда секция вызвавшей функции лежит сразу перед вызываемой и известны регистры вызвавшей, где находятся параметры.

image::102/param_indexing.png[]

Регистры вызвавшей функции индексируем как регистры вызываемой.

==== Выводы по явной передачи через регистры:

`-` В сравнении с стековой передачей инструкции длиннее -> порождаемый код длиннее (хотя инструкций меньше)

`-` Сложнее декодирование инструкций

`-` сложнее код компилятора в VM 

* минимизируем число виртуальных регистров 
* следим за живостью регистров (верификация, сборка мусора, рефлексия (какие переменные инициализированы)) -- хранятся в сжатых регистрах где-то в метаданных.
** в стеке мертвые значения просто снимаются со стека, здесь -- хранятся в таблице.

`+` это может упростить распределение регистров в динамическом компиляторе

=== Неявная передача через стек операндов

Нужно следить за глубиной стека, требуем чтобы она была легко вычислима (и идентична в разных потоках управления). 
 
Считаем нужную для выполнения функции глубину стека, при входе в функцию -- проверяем, хватит ли места на стеке. Если нет -- верификатор падает с ошибкой.

`+` упрощается набор виртуальных инструкций (простые спенциализированные инструкции для работы со стеком) 

`+` упрощается интерпретатор и компилятор

=== Сравнение сгенерированного кода

image::102/compare_vregs_and_stack.png[]

Через регистры -- 3 инструкции, использовали 3 виртуальных регистра. Если каждый из них занимает байт в записи вызова, то потратили 10 байтов.

Через стек -- 6 инструкций, 9 байтов. Если начальные значения уже на стеке, то получим 4 инструкции и 5 байтов.

=== Сравнение интерпретаторов

image::102/compare_vargs_and_stack_interpret.png[]

Справа -- вид операции, слева -- код интерпретатора


=== Доступ к непосредственным операндам инструкции

xref:1/104.adoc[Здесь]

