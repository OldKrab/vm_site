= 1.12. Макроподстановка вызовов простых функций в интерпретаторе

46:25

Почему раньше не подставили:: Конвертору не был известен код вызываемой функции. Например, не было класса -- его загрузили позже или создали динамически.

Ограничения:: Интерпретатор не может анализировать код и должен сохранять его длину.

Как реализовать:: Путем сравнения с короткими образцами.

== Образцы 
Набор образцов 
* захардкожен в интерпретатор, который просто сравнивает и подставляет, не делая никаких осознанных замен
* может иметь звездочки и вопросики


Интерпретатор умеет быстро сравнить тело функции с образцом, и если сравнение успешно, то выполняем замену. *В образце* написано, на что нужно поменять вызов функции.

Когда тело функции стало известно -- сравниваем его с образцом. Если совпадение с образцами не найдено, то нужно пометить инструкцию вызова, чтобы в будущем не пытаться сравнивать с образцами. Для этого обычно используют префиксные деревья.

 
== Другие проверки
 
Кроме совпадения с образцом нужно проверить 

* аттрибуты функции (например, synchronized)
* метаданные, таблицы try-catch. Если функция ловила исключение и мы заинлайним, то ловить исключение мб уже другая функция -- изменится семантика. 
* Также заменяемая инструкция вызова, кроме непосредственно вызова, сама могла делать какие-то проверки и бросать исключения. Они тоже должны бросаться.

=== Исключение

Подстановка заметна при бросании исключений (нет трассы стека). Можем не бросать код, который бросает исключения, но его в языке может быть мало (в jvm, например).

Другое решение -- записать подстановки в _журнал замен_ функции (табличка, размер ограничен конвертором):

* Интерпретатор добавляет запись о замене в таблицу при макроподстановке
* При исключении интерпретатор проверит, было ли оно брошено в подставленной функции
* Если в подставлено коде -- проверяет, бросило ли его сама инструкция вызова, или оно выброшено в теле функции
* Если в теле, то определяем смещение  внутри функции и смотрим, что там было (мб рекурсивный вызов макроподставленных функций)
* Добавляем секцию в трассу стека

КаРтИнКа:

== Пример 
Попробуем использовать ограничения подстановки в интерпретаторе в свою пользу. 

image::112/image.png[]

=== Специализация метода класса

Находимся в коде на инструкции вызова функции  

image::112/1.png[]

Функция ссылается на дескриптор метода в константном пуле. У дескриптора -- имя класса и метода, сигнатура вызова (параметры, возвращаемый тип). 

image::112/2.png[]

При первой попытке исполнения инструкции мы разрешаем дескриптор метода. Ищем класс, по имени метода -- его реализацию в классе, если методов несколько с одним именем -- ищем по сигнатуре. 

Если не нашли -- кидаем ошибку (ленивой линковки).

В данном случае нашли метод снизу справа.

* aload_0 (загрузка параметра this)

image::112/3.png[]

Сравниваем с образцом. Пусть его тело совпало. Field, который передается в параметре --- та самая звездочка -- переменная часть образца. 

image::112/4.png[]


Тогда меняем вызов функции на заданную образцом последовательность: в данном случае доступ к полю field (извлекаем это из образца, в данном случае -- из середины метода).

image::112/5.png[] 

=== Специализация гетера 
Мы еще никакой инструкции не исполнили! Интерпретатор переписывает байтики. Эту замену не сделал конвертор, так как он не знал класс myClass.

Лезем в дескриптор поля. Он еще не разрешен. Лезем в список полей, ищем по этому имени тип и вычисляем смещение. Меняем инструкцию и исполняем ее.

image::112/6.png[]

== Варианты образцов
Так как мы выполняем разные замены, то хочется завести много разных образцов. Рассмотрим пример, когда меняем акцессоры. 

image::112/образцы.png[]

=== Замена 1
`aload_0` -- загрузить параметр this 

`getfield field` -- обращение к полю со ссылкой в константный пул

возвращаем значение какого-то типа (он совпадает с типом поля во второй инструкции, это проверяет верификатор если он есть) 

image::112/обр1.png[]

Просто заменяем это на вызов гетера у поля: вырезаем байтики из середины паттерна и вставляем.

=== Замена 2
В теле функции уже есть <t> -- мы подставили его, когда раньше выполняли код внутри тела и подставили смещщение поля.

image::112/обр2.png[]


=== Замена 3 
Специализация уже была выпонена интерпретатором раньше --- просто раскрываем в вызов метода. 

image::112/обр3.png[]

=== Замена 4 
Специализация была выполнена конвертором (имеем суперинструкцию).

image::112/обр4.png[]

Не проверяем, что this == null. Извлекаем суперинструкцию. Просто вырезать кусочек и вставить мы не можем, т.к. нужно сделать проверку на null. 

=== Замена 5: суперинструкциии 

image::112/обр5.png[]

getfield специализирован по типу и делает проверку на null. Суперинструкции, на которые заменял конвертер думал, что aload никогда не будет null, т.к. это вызывается вызовом, который делает проверки на null.

Интерпретатор эту инструкцию устраняет, значит нужно делать какую-то проверку.


== Замена оставшихся идиом супер-инструкциями

Конвертор проанализировал код, нашел начало похожей на идиому последовательности, но там оказалась ссылка на неизвестный элемент и подставить не может.

Поэтому эта работа передается интерпретатору. Но он не может обработать это сам, т.к. он не может определить, нет ли метки внутри этой идиомы.

Если в коде ВМ есть явные метки -- анализ делать не нужно, у интерпретатора больше возможностей. Но их нужно исполнять, а декодировать  через табличку -- это долго. 

Чтобы интерпретатор знал, что переходов нет, конвертер помогает ему и ставим перед потенциальной идиомой вспомогательную инструкцию конвертора. 

image::112/more.png[]