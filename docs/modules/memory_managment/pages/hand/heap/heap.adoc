= Ручное отведение в «куче» 

«Куча» - обобщение пула для *произвольной*
дисциплины отведений-освобождений и
*произвольных* типов объектов. Вторичная система отведения памяти.

Аналогично пулам, может:

* быть фиксированного или переменного размера
* быть непрерывной или кусочной
* может включать в себя разные первичную и вторичную систему отведения

Расходы на синхронизацию обращений к глобальной куче при *многопоточной*
реализации могут быть существенными

Может быть не глобальной, а локальной в потоках, но так можно получить указатель на объект из соседнего потока.

== Фрагментация

=== Для мелких объектов *внутренняя*
фрагментация может быть значительной


* Округление размера

* Обрамление объекта (header & footer)

=== Внешняя фрагментация

Коэффициент внешней фрагментации памяти
пропорционален логарифму отношений
максимального и минимального размеров объектов

J.M.Robson. An estimate of the store size necessary for
dynamic storage allocation. Journal of the ACM, July 1971.


== Программный интерфейс

```cpp 

void* allocate(size_t size)

```


* Отвести блок памяти для размещения одного или
более объектов указанного суммарного размера. При size=0 может, но не обязан выдать NULL

* При исчерпании памяти выдает NULL или кидает
исключение

```cpp 

void free(void* p)

```


* Освободить ранее отведенный блок

* Здесь p - ранее полученный результат allocate,в
т.ч. NULL

Вариант (не популярный в современных системах) с указанием размера блока (считается компилятором)

```cpp 

 void free(void* p, size_t size)

```


* Компилятор берет под свою ответственность
быстрое вычисление размера блока

* Обычно применяется для блоков, состоящих из
отдельных языковых объектов

* Размер объекта вычисляется по его типу (в
частности, размер может быть записан в объект,
его класс или VMT). Это имеет смысл не для всех
реализаций языков


```cpp 

void* resize(void* p, size_t new_size)

```


* Изменить размер на месте или путем копирования

* Здесь p - ранее полученный результат allocate,в
т.ч. NULL

Вариант с размером старого блока 

```cpp 

void* resize(void* p, size_t old_size, size_t new_size)

```


* Изменение на месте — полезная, но не
обязательная оптимизация последовательности

* Отвести блок нового размера

* Скопировать в его начало содержимое старого

* Освободить старый блок

* Могут быть дополнительные функции для отладки
и тестирования (heapwalk, heapdump)


== Элементы реализации 

=== Гарантированное выравнивание

Инструкции процессора могут требовать или работать
эффективнее с выровненными данными

Система отведения «кучей» должна гарантировать
максимальное требуемое выравнивание адреса (если есть разные типы, для которых гарантируется выравнивание -- выбираем размер максимального типа)


* Смещения полей объектов с учетом их выравниваний назначит компилятор

* Выравнивание *начального адреса* гарантируется системой отведения памяти

* Для уменьшения размера объектов поля лучше отсортировать в порядке уменьшения выравнивания (если в языке программирования это запрещено -- нужно делать вручную)

=== Округление размера вверх


* Обычно до максимального требуемого выравнивания, чтобы следующие отведения тоже были выравнены

* Большие объекты могут округляться и выравниваться
на большую границу (например, на границу памяти)

* Потери на округление являются элементом внутренней фрагментации

Формула для фактическое количество отведенной памяти

```cpp

allocation_size(size) = max(round_up(size) + live_block_framing, min_block_size)

```

=== Обрамление блоков

Система управления «кучей» может хранить
связанные с блоком служебные данные до
(заголовок, `header`) и после него (`footer`)

В свободном блоке можно хранить больше служебных
данных, чем в занятом, но *минимальный размер
свободных и занятых блоков одинаков*

Передача размера компилятором в запросы может исключить или снизить потребность в обрамлении

=== Деление (расщепление) блоков (block splitting)

Если при отведении блока не удается найти точно
подходящий ему по размеру свободный блок, можно:

* Запросить у первичной системы отведения больше
памяти

* Или отвести блок большего размера (часть памяти
при этом станет недоступной для отведения)

* Или разделить блок большего размера на
требуемый блок и оставить *остаток* свободным

* Не обязательно стремиться к минимизации остатков

=== Слияние соседних свободных блоков (block coalescing)

У освобождаемого блока могут оказаться свободные
соседи непосредственно до и после него.

Эти блоки можно слить для образования блока
большего размера и снижения числа блоков

Не всегда слияние сразу при освобождении является
лучшей стратегией.  Ближайший запрос на отведение может потребовать
деления только что слитого блока

=== Классы размеров

Отводимые блоки делятся на классы по размеру. Например, малые, средние и большие

Разные классы размеров могут управляться
различными механизмами

Не все механизмы одинаково пригодны для всех
классов размеров

== Традиционные классы механизмов управления «кучей»


* Последовательный поиск подходящего блока

 First Fit, Next Fit, Best Fit, Worst Fit с вариациями

* Разделение объектов по размерам

 Раздельное хранение (Segregated Storage) и раздельный поиск (Segregated Fit)

 Раздельное хранение позволяет определить размер объекта по его адресу без использования заголовка

* Метод близнецов
 
 Двоичных, взвешенных (несколько двоичных серий с малыми весами), Фибоначчиевых и двойных (3=2+1)

* Индексированный поиск
 
  Indexed Fit (структуры поиска блока по размеру)

* Поиск в битовом массиве

* Bitmapped Fit 