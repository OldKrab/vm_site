=  Последовательный поиск подходящего блока


== Пул как основа 

Возьмём в качестве основы любой последовательный пул


* Непрерывный или кусочный

* Фиксированного или переменного размера

* С восходящим или нисходящим отведением (для определенности будем использовать восходящее отведение)

image::hand/heap/sequential/1.png[]

Пул обеспечивает 

* отведение памяти 

* освобождение последнего отведенного блока (любой последовательности последних отведенных блоков)

* сокращение размера блока
на месте и увеличение путём его копирования

image::hand/heap/sequential/2.png[]

* пул с восходящим отведением обеспечивает
увеличение размера последнего блока на месте

== Список свободных блоков 

Дополним пул системой *повторного использования освобождённых блоков*

 Заводим "корзину", в которую заносим освобожденные объекты


* Освобождение произвольного блока помещает его в эту систему

* Последний отведённый пулом блок лучше освободить средствами пула и вернуть обратно в пул

При отведении блока сначала пытаемся повторно использовать ранее освобождённый блок. Для этого надо знать размеры свободных блоков и их расположение

Снабдим освобождённый блок заголовком,
запишем в него размер и адрес следующего
свободного блока

Это можно сделать, если минимальный размер
блока 2 слова

image::hand/heap/sequential/3.png[]

== 16 байт
В 64 битной системе два слова занимают 8 байт, создавать объекты меньшего размера не получится. Для компактного хранения объектов меньшего размера можно использовать оптимизации 

=== Вариант 1: отдельный механизм для класса маленьких размеров
отнесём мелкие блоки размером в одно
слово к другому классу размеров и используем
для них другой механизм

=== Вариант 2: использование заголовка блока

Если блок снабжён заголовком, в котором
хранится его размер, младший бит размера не используется из-за
выравнивания. Поместим в него признак занятости блока


* Минимальный размер объекта 0 слов

* Минимальный размер блока 1 слово (заголовок)

Замедление поиска подходящего свободного блока —
нужно последовательно сканировать все объекты,
включая занятые

Уменьшили внутреннюю фрагментацию

image::hand/heap/sequential/4.png[]

== Стратегии поиска подходящего свободного блока

* First Fit - начинаем с начала, ищем первый блок
нужного или большего размера

* Next Fit - аналогично, но начинаем с позиции, в
которой успешно закончился предыдущий поиск,
иначе с начала

* Best Fit - ищем наиболее подходящий по размеру
блок

* Worst Fit — ищем точно совпадающий по размеру или
наименее подходящий блок, делим его в надежде на
более вероятное будущее использование остатка. Имеет смысл только при поддержке деления блоков

== Деление блоков 

Легко осуществимо, если размер остатка не меньше
размера минимального блока. Иначе остаток не может быть оформлен как
отдельный свободный блок и может быть только
использован при расширении блока на месте (а это редкий случай)

== Слияние блоков
Для слияния с предыдущим блоком нужно знать,
свободен ли он. Для этого нужно найти его заголовок

После слияния нужно обновлять системные данные, если они хранились в теле освобожденного блока.

=== Метод граничных признаков 
Предположим, что

* блок снабжен заголовком, в котором хранится его размер

* блоки выровнены минимум на 4 байта и поэтому 2 младших бита размера свободны

`header`: одно слово, хранит размер блока. Т.к. блоки выровнены, используем два младших бита

Последний бит -- занят ли текущий блок, предпоследний -- занят ли *предыдущий* блок 

`footer`: В конце свободного блока дополнительно сохраним его размер
 
D.Knuth. The Art of Computer Programming. Volume 1:
Fundamental Algorithms. Addison-Wesley, 1973

image::hand/heap/sequential/5.png[]

image::hand/heap/sequential/6.png[]

==== Слияние с предыдущим свободным блоком 

Освобождаем нижний блок. Если предыдущий блок свободен -- считаем в  его футере размер блока. Затем увеличиваем заголовок верхнего блока и размер объединенного блока в футере нижнего. 

image::hand/heap/sequential/7.png[]

==== Слияние со следующим свободным блоком

image::hand/heap/sequential/8.png[]

По текущего блока узнаем заголовок следующего. Если он свободен -- сливаем.

=== Об алгоритме
[pluses]

* Этот механизм пригоден для широкого класса
размеров и всевозможных организаций «куч»

[minuses]
* Основной недостаток - линейная сложность по числу блоков (т.е. размеру кучи)

Нужны дополнительные структуры (деревья) для ускорения поиска. Их узлы можно размещать внутри свободных блоков. От этого минимальный размер блоков увеличится, т.к. он одинаковый и у свободных и у занятых блоков. Поэтому лучше мелкие объекты выделить в отдельный класс и использовать для него отдельный механизм, т.к. искать места для маленьких объектова гораздо проще.


Увеличение размера на месте возможно:

* Если есть свободное место в конце блока

* Если следующий за объектом блок свободен

* Для последнего отведённого пулом блока