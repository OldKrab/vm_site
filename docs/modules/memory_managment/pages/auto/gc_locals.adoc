= Просмотр локальных переменных 

Локальные переменные и параметры содержатся в секциях *программных стеков*. Там же может располагаться необходимый некоторым VM стек операндов.

Свойства программных стеков:

* часто изменяются
* бывают глубокими
* бывают многочисленными (у каждой сопрограммы и каждого потока свой стек)

Программные стеки и их секции могут быть устроены по-разному в зависимости от кода(1):

* интерпретируемого
* скомпилированного
* нативного (написанного на C/C++ по специальным правилам нашей реализации)
* чужого (с некоторым стандартным интерфейсом отведения памяти, который мы используем)

При просмотре корней сборщик мусора должен пройти по ссылкам в кучу из всех стеков. Варианты реализации поиска указателей:

* Зарегистрированный локальный массив ссылок
* Список «умных указателей»
* Карты ссылок секций стека

Не все варианты одинаково пригодны для разных программных стеков и их секций(1):

* Некоторые более удобны при наличии в языке реализации конструкторов, деструкторов, макросов и шаблонов (если писать такой код не на C++, а на C)
* Карты ссылок применимы только к секциям кода, порождённого дружественным компилятором. В т.ч. конвертором в исполняемый код

== Локальный массив ссылок
Функция 

* отводит локальный массив ссылок статически известного размера
* регистрирует его
* по окончании регистрация удаляется

Если код пишется вручную на C/C++, именование, типизацию и подсчёт ссылок можно облегчить при помощи макросов и шаблонов, а регистрацию и её удаление - при помощи конструктора и деструктора

При регистрации массив вставляется в список. При нативной многопоточности у каждого потока свой связный список, иначе этот список глобальный

image::auto/gc_locals/local_links.png[]

next -- служебное поле

элементы массива содержат ссылки на кучу (если они не null)

== Список локальных умных указателей

* Каждый указатель снабжен полем для регистрации его в списке
* Конструктор добавляет объект в список, деструктор из него удаляет
* Деструкторы должны вызываться в порядке, обратном конструкторам, иначе ссылку на удаляемый элемент придется искать в списке (т.к. в современном с++ порядок деструкторов обратен порядку деструкторов).
* При нативной многопоточности у каждого потока свой связный список, иначе этот список глобальный и регистрировать в нем будет тяжело.

[pluses]
* Проще в использовании

[minuses]
* для множественных локальных ссылок менее эффективен, чем массивы. Т.к. часто происходит регистрация указателей в списки (происходит больше действий)
* многие оптимизации автоматически отключаются, если ссылка утекает в глобальные

image::auto/gc_locals/local_smart_pointers.png[]

== Карты локальных переменных
Карта -- битовый массив, который готовит, что в этих переменных есть ссылки в кучу. 

* При сканировании стека в точке сборки мусора проходим по всем его секциям
* В каждой секции проходим по локальным переменным и ячейкам стека операндов, содержащим ссылки в кучу
* Они зависят от адреса текущей инструкции в данной секции
* Расположение ссылок в кучу для данного адреса задается картой локальных переменных и стека
* Кроме сборщика мусора, похожие карты могут быть нужны верификатору и отладчику. Им нужны карты не только ссылок и не только в
точках сборки мусора

[minuses]
* В отличие от списков массивов и отдельных указателей требуют поддержки компилятора

[pluses]

=== Представления карт локальных переменных и стека операндов

1. Виртуальный код

 Он должен содержать достаточно данных для вычисления карт конвертором или загрузчиком. Верификация кода может происходить при конверсии или загрузке. Поэтому эти данные должны быть в не зависящем от реализации и притом компактном представлении (как и весь виртуальный код).

2. Метаданные (аннотации) исполняемого кода

 Порождаются конвертором или загрузчиком кода. Должны быть достаточно компактны и эффективно декодируемы. 
 

Метаданные могут зависеть от реализации ВМ и параметров её запуска

 * Сборщику мусора интересны только ссылки в точках сборки

 * Отладчику интересны все локальные переменные и ячейки стека во всех консистентных состояниях программы, но скорость доступа не критична

=== Сжатие карт локальных переменных и стека операндов
Карт может быть много, они могут занимать существенное место в памяти (например, для отладчика метаданные стоят после каждой инструкции).

Карты нужно уметь повторно использовать и
сжимать. Возможности для сжатия:

* В картах много избыточности
* Ячейка секции в разные моменты может использоваться для хранения переменных разных локальных сред (переменные разных типов в разных локальных блоках)
* В некоторых языках эти переменные могут быть ссылочного и не ссылочного типов
* Эти переменные отводятся для блоков и потому живут в интервалах адресов инструкций
* Стек операндов последовательно меняется с помощью небольшого числа виртуальных инструкций. 


Содержание карт должно соответствовать
возможностям компилятора

==== 1. Таблица типов локалов на функцию

Если компилятор:

* не использует одну и ту же ячейку секции для
ссылочных и не ссылочных данных (знате, что у них разные типы)
* … гарантирует инициализированность всех
локальных ссылок функции во всех точках сборки

image::auto/gc_locals/compression.png[]

Ошибка, т.к. в самом начале переменная, а не инициализирована никак (точка сборки). Компилятор должен породить более хитрый код и сначала инициализировать объект как null.

* … затирает мёртвые локальные ссылки null'ом

То можно обойтись единственной таблицей типов локальных переменных на функцию

* Но придется породить много предварительных
инициализаций и затираний мёртвых ссылок
* Такой код менее эффективен и занимает больше
места, чем карты (т.к. очень много присваиваний null)

==== 2. Сигма-сжатие карт локалов
карта говорит, является ли переменная указателем в кучу.

* Сигма-сжатие карт локальных переменных
* Для каждой ячейки секции функции узнаем, может
ли ее когда-либо занимать локальная переменная
ссылочного типа, не равная null
* Т.е. вычислим логическую сумму её свойств во всех
точках сборки мусора функции
* Закодируем карту битовой шкалой флагов
* В дальнейшем идентифицируем ссылочную ячейку
её порядковым номером среди единичных битов

image::auto/gc_locals/sigma_compress.png[]

[minuses]
Эффект сжатия небольшой 

==== 3. Дельта-сжатие карт локалов

Применяется после сигма-сжатия.

Поскольку карты остаются постоянными в
интервалах адресов инструкций, будем повторно
использовать карту, пока она не изменится

Изменение происходит после строго
положительного приращения адреса

* Закодируем его парой (приращение адреса,
изменение как битовая карта для XOR)
* В картах для верификатора и отладчика меняется
единственный бит — кодируем его номером бита
* Приращение обычно мало, используем для него
кодировку с переменным числом битов

image::auto/gc_locals/delta_compress.png[]

Есть сигма карта с предыдущего слайда. 

Основной недостаток — последовательная
распаковка карт

* Для получения карты для данного смещения нужно
распаковать все предыдущие
* Если в коде функции много сжатых карт, нужно
ускорить поиск
* Например, старшие биты смещения используются
как индекс в таблице входов (предыдущее
смещение, предыдущая карта, следующий индекс
в сжатой таблице)
* Или бинарный поиск ближайшего снизу элемента в
аналогичной таблице

==== 4. Сжатие состояния стека операндов
* Варианты:
* Считать стек частью локальных переменных
* Абстрактная интерпретация виртуального кода,
начиная с карты локалов (??) и стека в начале базового
блока
