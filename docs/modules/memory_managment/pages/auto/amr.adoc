= Автоматическое освобождение памяти (automatic memory reclamation)

Библиотека автоматического освобождения памяти следит за достижимостью объектов
посредством «умных указателей». Прочие указатели игнорируются. Чтобы библиотека могла работать, вводиться запрет или ограничение адресной арифметики, приведений типов и неразмеченных объединений

*Типы ссылок на объекты*

* `Handle<Type>` -- умный указатель, единственный источник данных
для библиотеки освобождения
* `Type*` -- Обычный опасный указатель, может быть получен
приведением из умного, библиотекой игнорируется
* `const Handle<Type>&` -- Ссылка на умный указатель

** Безопасна, библиотекой игнорируется
** Лишняя косвенность при доступе к объекту

== Характеристики AMR

[pluses]
* Библиотечное расширение
* Не требует поддержки со стороны кучи и компилятора
* Совместимость со старым кодом: он может по-прежнему управлять памятью вручную
в той же куче
* Своевременное освобождение объекта сразу после
утраты последней ссылки на него

[minuses]
* Опасность внешней фрагментации
* Усложнение программных интерфейсов несколькими
видами ссылок
* Ограничения области применения

Варианты реализации

* Уникальные указатели
* Счётчики ссылок


== Уникальные указатели
При создании объекта с ним связывается
уникальный указатель. Например, `std::unique_ptr<Type>` в С++

Ссылка на объект из уникального указателя
может быть утрачена 

* Уничтожение уникального указателя
* Присваивание ему другого объекта

При утрате ссылки уникальный указатель
вызывает освобождение объекта


Ограниченное применение:

* У каждого объекта должен быть владелец
* Нужен протокол передачи права владения объектом
* Но во многих применениях у объекта нет никакого естественного владельца (например, в двусвязном циклическом списке все узлы и ссылки равноправны)

