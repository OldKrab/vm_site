= Классификация сборщиков мусора

* Точный (знает все ссылки) или консервативный 
* Объекты подвижные (могут менять адрес в памяти) или неподвижные (где отвели -- там и лежат)
* Direct pointers vs. Object handles (таблица, где есть объект. обращемся к нему по индексу)
* Непрерывная или кусочная куча
* Полная или выборочная (в какой-то чатси кучи) сборка
* Приостанавливающая (синхронная, Stop-The-World STW) или Постепенная/Инкрементальная (Concurrent/Incremental)
* Одно- или многопоточная

== Точный или консервативный 

#Точная сборка# — известны все указатели

* Можно достоверно установить достижимость объекта от корней по ссылкам
* Можно перемещать объекты
* Куча может быть дефрагментирована
* Простые и быстрые алгоритмы отведения

#Консервативная сборка# — не все указатели известны

* Вариант 1: никакие указатели не поддаются точной идентификации
* Вариант: ссылки между объектами в «куче» и статические корни известны, а динамические корни — не вполне (ambiguous roots collection). Возникает, если компилятор писал кто-то другой и никакой информации для сборки мусора не описал.

Не все объекты можно перемещать

* Опасность фрагментации
* Простое использование указателей
* Более сложное и медленное отведение по сравнению с точной (нельзя двигать указатель, ходим вокруг объектов)

== Direct pointers vs. Object handles

#Object handle# (Ordinary Object Pointer, OOP) — номер регистрационной записи объекта в центральной таблице объектов

[pluses]
* Ускорение и атомарность перемещения объекта 
 переметили объект в куче и переместили адрес в таблице. никаких ссылок модифицировать не нужно
* Идентификация объекта по его индексу (у true, false и разных классов свои индексы)
* Лёгкая подмена объекта (became в smalltalk для получения нового состояния объекта из старого)
* Лёгкий перехват обращений к объекту (проставляем в элементе аттрибут или объект-прокси, можно поставить точку останова)

[minuses]
* Замедление доступа (дополнительная косвенность)
* Таблица объектов может переполниться

image::auto/gc_class/oop.png[]

== Куча непрерывная или кусочная 

Динамическое изменение размера кучи

 При страничной адресации можно по максимуму зарезервировать диапазон адресного пространства и по мере необходимости отображать туда память (домашка про пул графа). Куча может менять размер, даже если она не кусочная.


При фиксированном размере кусков большой объект может не поместиться в один кусок

 Нужны куски разных размеров или кусочное представление объектов 

Неиспользуемое место в конце кусков

Проверка принадлежности адреса куче:

* Для *непрерывной* кучи это простая проверка принадлежности адреса диапазону
* Для *кусочной* это поиск куска по адресу внутри него (обычно в какой-то структуре данных)

Возможность освобождения куска целиком при утрате всех ссылок снаружи на его объекты (в непрерывном такой операции нет)

В кусочной отдельный кусок как единица выборочной сборки. В непрерывной куче — вычислить один или несколько диапазонов адресов

В кусочной отдельный кусок как единица работы при параллельной сборке. В непрерывной куче — назначить диапазон адресов и раздавать их потокам внутри сборки мусора.

== Сборка полная или выборочная