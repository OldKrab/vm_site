= Алгоритм обращения указателей (Йонкерса)

== Обращение и прошивка указателей 
Способ обращения отношения «ссылается на» без использования дополнительной памяти

Как поставить в соответствие объекту множество ссылающихся на него указателей?

* представить это множество односвязным списком

* корень списка разместить в объекте

* в качестве полей ссылок в списке использовать сами указатели

image::media/1.png[]

Важно, чтобы заголовок объекта можно было отличить от ссылки на поле объекта (заголовок нечетный (?) или должен располагаться в адресном пространстве, где объекты-поля не расположены)

```cpp
//
inline bool is_pointer(const void* p) {
    return (uintptr_t(p) & 1) == 0;
}
```

```cpp
//связывает указатель в список
inline void link(void** pp) {
    void** p = (void**)*pp;
    if (p) {
        *pp = *p;
        *p = (void*)pp;
    }
}
```


```cpp
//obj -- корень списка
//после работы алгоритма -- указатель на исходный объект

//dst -- место, куда нужно переместить объект,
//после работы алгоритма все указатели из списка указывают на него

//можем релоцировать объект с одного места на другое,
//этот же метод обновляет все указатели
inline void resolve(void* dst, void* obj) {
    void* p = *(void**) obj;
    if (is_pointer(p)) {
        do {
            void** q = (void**)p;
            p = *q;
            *q = dst;
        //достигли последнего поля
        } while (is_pointer(p));

        *(void**)obj = p;
    }
}
```

Широко используется в загрузчиках, линковщиках, однопроходных ассемблерах и компиляторах для разрешения ссылок вперед на метки без дополнительных таблиц

Необходимые условия

* Размер объекта достаточен для размещения в нем указателя
* Указатели могут ссылаться только на начало объектов
* Можно отличить указатель от хранящегося в начале объекта значения
** Например, поля-указатели выровнены, а объект снабжен заголовком с единицей в младшем бите
** Или заголовок объекта содержит тег его типа, заведомо меньший адреса любого поля (все теги лежат в конкретной области памяти)


F.Lockwood Morris. A time- and space-efficient garbage collection
algorithms. Communications of the ACM, 21(8), August 1978.

== Фазы алгоритма 
Три прохода по куче 

=== 1. Пометка достижимых объектов
Если бит пометки хранится в одном из младших битов заголовка объекта, лучше инвертировать смысл этого бита (0 — помечен, 1 — не помечен). Тогда он сохранится при последующем обращении указателей из-за выравнивания адресов ссылок

Иначе нужно сохранять бит пометки при прошивке

Алгоритм такой же с точностью до инверсии флага

=== 2. Корректировка ссылок вперед

```cpp
inline void update_forward_pointers(void) {
    //обращаем ссылки на объекты из корней
    forEachRoot(ref) link(ref);

    //идём по куче снизу вверх
    Byte* dst = HeapBottom;
    for (Byte* src = dst; src < AllocationTop;) {
        if (is_marked(src) == false) { // link переписывает заголовок
            //идем по освобожденным объектам, 
            //накапливая "дельту" для перемещения объекта
            src += allocation_size(src);
        } else {
            //дошли до достижимого, помеченного объекта
            //здесь src указывает на указатели
            resolve(dst, src); 
            // Заголовок восстановлен - можно вычислять размер
            const unsigned size = allocation_size(src);
            // Объект может ссылаться на себя – при обращении его
            // ссылочных полей может измениться заголовок.
            // Просмотр ссылочных полей должен это учитывать.
            forEachRef(ref, src) link(ref);
            // Здесь размер вычислять уже нельзя!
            src += size;
            dst += size;
        }
    }

    allocation_size -- ??
}
```
=== Корректировка ссылок назад, очистка пометки, уплотнение

```cpp
inline Byte* compact_and_update_backward_pointers(void) {
    Byte* dst = HeapBottom;
    for (Byte* src = dst; src < AllocationTop;) {
        if (is_marked(src)) { // link переписывает заголовок
            resolve(dst, src);
            unmark(src); // Если пометка в битовой карте
            // Заголовок восстановлен - можно вычислять размер
            const unsigned size = allocation_size(src);
            // Объекты в основном маленькие, копируем вниз
            move(dst, src, size);
            src += size;
            dst += size;
        } else {
            src += allocation_size(src);
        }
    }
    return dst;
}
```

== Сравнение алгоритма Йонкерса с алгоритмом отсылочных указателей

* Одним просмотром кучи меньше
* В остальных просмотрах производится значительно больше изменений памяти
* Низкая локальность обращений к памяти при прошивке указателей
* Только фаза пометки поддается распараллеливанию, в остальных фазах прошитые указатели создают множественные зависимости между объектами