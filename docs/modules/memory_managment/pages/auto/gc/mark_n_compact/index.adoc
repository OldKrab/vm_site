= Mark'n'Compact

Пометка с последующим уплотнением

* Отводим объекты в каком-либо пуле, обычно путем последовательного продвижения указателя AllocationTop (Pointer Bumping)

* Начиная с корней, обходим и помечаем все достижимые объекты
* Перемещаем живые объекты в один конец кучи
* Корректируем указатели, чтобы они указывали на новое место расположения объектов. В вариациях алгоритма корректировка указателей может производиться до, после или в той же фазе, что и перемещение объектов

Не избегаем фрагментации, а устраняем её!

image::media/1.png[]

== Перемещение объектов

* Нужна высокая пропускная способность памяти, неэффективно при узкой шине памяти

* Изменяется физический адрес объекта. Некоторые контроллеры используют физические адреса для асинхронных операций -- нужно 
** уметь *временно фиксировать* расположение объекта (`object pinning`) 
** или ждать завершения таких операций

* Устраняется фрагментация на уровне страниц виртуальной памяти

* Возможно снижение энергопотребления за счет выключения свободных банков памяти

* Возможно увеличение локальности ссылок за счет переупорядочения объектов: сохранение порядка отведения, обход графа ссылок, использование динамической статистики для попадание близких объектов в одну линейку кеша и т.д.

=== Труднопереместимые объекты 
==== Долгоживущие объекты

* В течение жизни многократно перемещаются
* К счастью, во многих алгоритмах стремятся осесть на дне кучи, после чего перестают перемещаться

==== Большие объекты

* Высокие затраты на пересылку в фазе уплотнения
* Часто бывают долгоживущими

==== Популярные объекты

* Объекты, на которые много ссылок
* Высокие затраты в фазе корректировки указателей
* Часто бывают долгоживущими

P.B.Bishop. Computer systems with a very large address space and
garbage collection. Ph.D. Thesis. Massachusetts Institute of
Technology, 1977

==== Объекты, требующие временной фиксации расположения в физической памяти
* Операции pin и unpin
* Часто являются большими (массивы)

Эти классы объектов являются устойчивыми -- принадлежность объекта ему сохраняется всю жизнь

* Распознавать, отдельно хранить, не перемещать
* Чтобы не перемещать объект, хорошо бы предсказывать его класс уже в момент отведения. И отводить в "правильном" месте. Объект можно идентифицировать вызовом его конструктора в динамическом контексте ограниченной глубины

== Способы корректировки указателей

=== Forwarding Pointer
Запоминание нового адреса на месте старого расположения объекта до или после перемещения объекта

=== Табличный поиск
По старому значению ссылки ищем его изменение (дельту)

=== Pointer Threading & Reversal
Прошивка и обращение указателей 
