= Счётчик ссылок

image::auto/link_count/link_counter.png[]

Цифры -- количество ссылок на объект.

George E. Collins. A method for overlapping and erasure of
lists. Communications of the ACM, 3(12), December 1960

Самый старый из алгоритмов автоматического
освобождения памяти. Используется во множестве систем (InterLisp,
Smalltalk-80, Modula-2+), библиотек и прикладных
программ (Adobe Photoshop, awk, Perl).


Каждый объект снабжается счётчиком ссылок, что увеличивает *размер заголовка* объекта. В простейшем случае в счётчике должно быть достаточно битов, чтобы избежать переполнения. 

При меньшем числе битов усложняются операции, по достижении максимального значения счетчика необходимо заменить переполнение *насыщением*. Объект с достигшим насыщения счётчиком никогда
не будет освобождён этим алгоритмом, для их освобождения нужен *другой* алгоритм, который будет собирать такие объекты.

Операции с насыщением для счётчиков ссылок в нескольких младших битах заголовка

Реализация для счетчика размером 3 бита. Легко укладывается в месте выравнивания. Код усложняется, появляется маскирование и условные инструкции.

```cpp
typedef uintptr_t header_t;
enum {
    COUNTER_BITS = 3,
    MAX_COUNTER = (1 << COUNTER_BITS) — 1
};
header_t counter(const header_t header) {
    return header & MAX_COUNTER;
}
bool is_counter_saturated(const header_t header) {
    return counter(header) == MAX_COUNTER;
}
void inc_counter(header_t& header) {
    if (!is_counter_saturated(header)) ++header;
}
void dec_counter(header_t& header) {
    if (!is_counter_saturated(header)) --header;
}

```

При создании ссылки на объект его счётчик
ссылок инкрементируется, при уничтожении —
декрементируется

Передача указателя на объект параметром вызова — частный случай создания ссылки. сначала создаем ссылки, после вызова -- эти временные ссылки нужно удалить.

* После вызова такая ссылка уничтожается
* Утяжеление вызова (?) пропорционально числу
передаваемых указателей
* Передача существующей ссылки по ссылке (&)
требует дополнительной косвенности при
обращении, но не сопровождается созданием и
уничтожением ссылок

[minuses]

* Лишняя запись в память (при инкременте/декременте) мешает компиляторным оптимизациям (alias analysis, instruction scheduling (уменьшаается диапазон переставления инстуркций)...)
* Требует синхронизации (атомарности операций) при многопоточной обработке. Циклы вокруг инструкций `DCAS/CAS2`. 
 
 David L. Detlefs, Paul A. Martin, Mark Moir, Guy L. Steele Jr. Lock-Free Reference Counting. Proceedings of the 12th annual ACM symposium on Principles of distributed computing. August 26-29, 2001.

 Если посмотреть эту статью, то сразу отпадет желание писать такой код. 

При присваивании ссылочной переменной старая ссылка уничтожается и создаётся новая: декремент счётчика старой ссылки и инкремент счётчика новой

Утяжеление присваивания — две нелокальные записи
в память в добавление к простой пересылке. Чаще всего происходят присваивания размещённым в регистрах локальным переменным

== Специальные случаи присваивания переменной:

* Самой себе: уничтожение значения после декремента счётчика, нужна проверка или инкремент до декремента (чтобы случайно не убить объект после декремента). Можно сначала инкрементировать.

*  NULL
** Если в языке значением ссылки может быть NULL,
необходима дополнительная проверка перед
изменением счётчика, т.к. у null счетчика вообще нет.
** В однопоточной реализации можно вместо NULL
использовать статически размещённый `NullObject` с
начальным счётчиком ссылок = 1
** В одно- и многопоточных реализациях со счётчиками
малой ширины также можно использовать `NullObject`
со счётчиком `MAX_COUNTER`. Тогда мы не будем этот счетчик никогда менять, т.к. он уже насыщен.

== Освобождение 
=== Рекурсивное освобождение

При падении счётчика до нуля декрементируем
ссылки из полей объекта и освобождаем его.

При использовании контейнеров и рекурсивных типов
возможно лавинообразное освобождение объектов
(простой пример - бинарное дерево)

* Утрата ссылки на корень влечет декремент ссылок
на сыновей
* Если счетчик ссылок какого-либо сына обнулился,
те же действия рекурсивно применяются к нему

Может случиться при любом присваивании указателю

*Критическая непредсказуемость* времени (неизвестно какое количество инкрементов/декрементов и декструкторов будет вызвано) и глубины программного стека для выполнения повсеместно
используемых элементарных операций

Для решения этой проблемы:

* Нужно оценить снизу счётчик ссылок значения в
левой части каждого присваивания
* Это нетривиально для динамически отводимых
объектов
* Если мы оценили, что после присваивания счетчик равен нулю, нужно оценить сверху
глубину рекурсии и суммарное количество ссылок

==== Отложенное освобождение 
Как бороться с непредстказуемостью? 

Если счётчик ссылок занимает полное слово,
можно рекурсию заменить итерацией по списку. Используем память обнулившегося счётчика в
качестве поля связи в списке ожидающих
финализации и освобождения объектов


От этого класса должны наследоваться все объекты в нашей системе (которая использует библиотеку)
```cpp
class RefCountedObject {
    union {
        uintptr_t count;
        RefCountedObject* next;
    } u;
    void inc() { ++u.count; }
    void dec() {
        if (--u.count) return;
            u.next = pending_list;
            pending_list = this;
    }
    virtual ~RefCountedObject() {}
    static void finalize_pending_objects();
    
    static RefCountedObject* pending_list;
};
```

pending_list -- статический список 

нужен статический 

В многопоточной реализации у каждого потока
свой список ожидающих освобождения
объектов. Декремент счётчика ссылок атомарный

==== Финализация списка ожидающих освобождения объектов

Нужно иногда вызывать, чтобы убить содержимое спискаю

* Верхний элемент отвязывается и финализируется (вызываем деструктор)
* При этом у его сыновей декрементируются счётчики и
при обнулении добавляются в начало списка
* Итерации повторяются до исчерпания списка

```cpp
void RefCountedObject::finalize_pending_objects(void) {
    for (RefCountedObject* p; (p = pending_list) != nullptr;) {
        pending_list = p->u.next;
        delete p; // Неявный вызов ~RefCountedObject
    }
}
```

==== Изменение времени и порядка финализации
При рекурсивной реализации сыновья финализируются *во время*  финализации полей родителя *в некотором порядке*

При отложенной реализации сыновья финализируются *после* финализации
родителя в *обратном порядке* (односвязный список — это `LIFO`)

Если вам важен порядок финализации сыновей:

* В `RefCountedObject::dec` вписываем объект в
статический временный список
* После вызова `delete` переносим его (поэлементно) в `pending_list`
* LIFO^2 = FIFO

Финализация и освобождение больше не
происходят сразу при утрате последней
ссылки. Объект попадает в список и леэит там до тех пор, пока мы не дернем за функцию освобождения. 

==== Когда вызывать финализацию списка ожидающих освобождения объектов?
Есть три варианта

* В конце оператора присваивания «умному»
указателю

** Минимальная задержка по сравнению с рекурсивной
финализацией
** Избавляемся от стека (больше не может быть программного стека неизвестной глубины), но не от неопределенной
длительности выполнения присваиваний

* При отведении нового объекта

** Непредсказуемая задержка финализации и
освобождения после утраты последней ссылки
** Непредсказуемое замедление отведения памяти. В
куче это может быть незаметно, но как быть с пулами?

* Параллельно отдельным нативным потоком
** Только если реализация и без этого параллельна (иначе большие накладные расходы)
** Возможно, лучшая производительность
** Недетерминированная задержка финализации (непонятно когда она будет вызвана)


=== Постепенное освобождение 
Отложенное освобождение только *перемещает*
непредсказуемую длительность из
присваивания в вызов финализации списка. П#остепенное (инкрементальное) освобождение#
позволяет этот дефект устранить

Применимо только к блокам памяти одинакового
размера: типы объектов могут быть разными, но их размеры должны быть достаточно близкими для отведения блоков по максимуму размеров

Возьмём любую систему отведения с повторным
отведением при помощи односвязного списка. Например, ранее рассмотренную композицию последовательного и связного пулов.

Используем `free_list` в качестве списка объектов,
ожидающих финализации и освобождения. В исходной системе есть список свободных блоков, в которые мы хотим отводиить память. Объединяем его со списком освободившихся.

* В качестве поля ссылки используется обнулившийся счётчик
* При утрате последней ссылки объект просто вставляется в начало этого списка
* Если при отведении список не пуст, первый элемент финализируется и выдается, иначе память отводится в последовательном пуле


```cpp
inline void* allocate(void) {
    RefCountedObject* p = free_list;
    if (p) {
        free_list = p->u.next;
        p->~RefCountedObject();
        return p;
    }
    return (first_free -= size); //здесь мы можем и систменое отведение памяти использовать
}
```

[minuses]
* как и в пуле, все одного разщмера

==== Пример постепенного освобождения

image::auto/link_count/free.png[]

Содержимое списка `free_list` при 7 последующих отведениях памяти. Допустим, изначально список был пуст

1. `A`
2. `C -> B` (сначала добавили `B`, затем `C`)
3. `B` (ссылки из С не добавляем, т.к. на них еще ссылается B!)
4. `E -> D`
5. `F -> D`
6. `D`
7. `NULL`

Наблюдение: Финализация и освобождение
происходят со скоростью отведения памяти

* Список LIFO, поэтому задержка финализации объекта
в конце списка может быть очень длительной (почему последего?)
* При каждом отведении освобождаем `1+n` объектов из
`pending_list`(это что и где), переставляя лишние в `free_list`

Для ускорения частых присваиваний локалам исключаем их из счётчика ссылок

* Отдельный тип для локальных «умных указателей»
* Если счётчик ссылок упал до нуля, сканируем стеки. Сканировать стек дорого, поэтому мы зводим дополнительный список с нулевыми счетчиками.
* Если ссылок не нашлось, освобождаем объект
* Иначе записываем его в специальное множество ZCT (zero count table)
объектов с нулевыми счётчиками
* Периодически (когда могут образовываться ссылки. например, при выходе из секции
активации или переполнении этого множества)
*согласуем* стеки и ZCT

Если при согласовании обнаруживается объект с
ненулевым счётчиком, он исключается из ZCT

[minuses]
* Если при согласовании обнаруживается объект, на
который больше нет локальных ссылок, он
освобождается
* не обрабатывает циклические структуры

==== Циклические структуры

*Циклические структуры* не обрабатываются. Из-за взаимных ссылок счётчики элементов таких структур никогда не станут нулевыми. Во избежание циклов заводятся другие типы ссылок (дополнительные, которые не участвуют в счетчиках). 

Главный недостаток такого подхода:

[minuses]
* усложнение структур данных и программных
интерфейсов

Объекты без ссылочных полей не могут образовывать циклических структур

Для обработки циклических структур счетчики ссылок должны быть дополнены другим, лишённым этого недостатка алгоритмом

При использовании  двух алгоритмов, счётчики ссылок используются как *способ ускорить освобождение объектов*. 

При этом появляется модификация в виде #однобитовых счётчиков#, размещаемые не в объекте, а в одном из свободных битов *указателя на него*

* Нулевой бит означает уникальность ссылки на объект
* Необходимо маскировать бит счётчика указателя при
обращении к объекту. Операция довольно дешевая. 
